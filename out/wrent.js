/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var Wrent;Wrent =
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Parser\": () => /* binding */ Parser\n/* harmony export */ });\n\n// The maximum depth that interpolation can nest. For example, this string has\n// three levels:\n//\n//      \"outside %(one + \"%(two + \"%(three)\")\")\"\nlet MAX_INTERPOLATION_NESTING = 8;\n\n\nclass Keyword {\n    constructor(identifier, length, tokenType) {\n        this.identifier = identifier;\n        this.length = length;\n        this.tokenType = tokenType;\n    }\n}\n\n// The table of reserved words and their associated token types.\nlet keywords = [\n    new Keyword('break',     5, 'TOKEN_BREAK'),\n    new Keyword('class',     5, 'TOKEN_CLASS'),\n    new Keyword('construct', 9, 'TOKEN_CONSTRUCT'),\n    new Keyword('else',      4, 'TOKEN_ELSE'),\n    new Keyword('false',     5, 'TOKEN_FALSE'),\n    new Keyword('for',       3, 'TOKEN_FOR'),\n    new Keyword('foreign',   7, 'TOKEN_FOREIGN'),\n    new Keyword('if',        2, 'TOKEN_IF'),\n    new Keyword('import',    6, 'TOKEN_IMPORT'),\n    new Keyword('in',        2, 'TOKEN_IN'),\n    new Keyword('is',        2, 'TOKEN_IS'),\n    new Keyword('null',      4, 'TOKEN_NULL'),\n    new Keyword('return',    6, 'TOKEN_RETURN'),\n    new Keyword('static',    6, 'TOKEN_STATIC'),\n    new Keyword('super',     5, 'TOKEN_SUPER'),\n    new Keyword('this',      4, 'TOKEN_THIS'),\n    new Keyword('true',      4, 'TOKEN_TRUE'),\n    new Keyword('var',       3, 'TOKEN_VAR'),\n    new Keyword('while',     5, 'TOKEN_WHILE'),\n    new Keyword(null,        0, 'TOKEN_EOF') // Sentinel to mark the end of the array.\n];\n\nclass Parser {\n    constructor(source) {\n        // The source code being parsed.\n        this.source = source;\n\n        // The beginning of the currently-being-lexed token in [source].\n        this.tokenStart = 0;\n\n        // The current character being lexed in [source].\n        this.currentChar = 0;\n\n        // The 1-based line number of [currentChar].\n        this.currentLine = 0;\n\n        // The most recently lexed token.\n        this.current = {\n            type: undefined,\n            length: 0,\n            line: 0,\n            value: undefined\n        };\n\n        // The most recently consumed/advanced token.\n        this.previous = {\n            type: undefined,\n            length: 0,\n            line: 0,\n            value: undefined\n        };\n\n        // Tracks the lexing state when tokenizing interpolated strings.\n        //\n        // Interpolated strings make the lexer not strictly regular: we don't know\n        // whether a \")\" should be treated as a RIGHT_PAREN token or as ending an\n        // interpolated expression unless we know whether we are inside a string\n        // interpolation and how many unmatched \"(\" there are. This is particularly\n        // complex because interpolation can nest:\n        //\n        //     \" %( \" %( inner ) \" ) \"\n        //\n        // This tracks that state. The parser maintains a stack of ints, one for each\n        // level of current interpolation nesting. Each value is the number of\n        // unmatched \"(\" that are waiting to be closed.\n        this.parens = Array(MAX_INTERPOLATION_NESTING);\n        this.numParens = 0;\n\n        // If subsequent newline tokens should be discarded.\n        this.skipNewlines;\n\n        // Whether compile errors should be printed to stderr or discarded.\n        this.printErrors;\n\n        // If a syntax or compile error has occurred.\n        this.hasError;\n\n\n        this.tokens = [];\n\n        for (let i = 0; i < 85; i++) {\n            this.nextToken();\n        }\n\n    }\n\n    // Returns true if [c] is a valid (non-initial) identifier character.\n    isName(c) {\n        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';\n    }\n\n    // Returns true if [c] is a digit.\n    isDigit(c) {\n        return c >= '0' && c <= '9';\n    }\n\n    // Returns the current character the parser is sitting on.\n    peekChar() {\n        return this.source[this.currentChar];\n    }\n\n    // Returns the character after the current character.\n    peekNextChar() {\n        return this.source[this.currentChar + 1];\n    }\n\n    // Advances the parser forward one character.\n    nextChar() {\n        let c = this.peekChar();\n        this.currentChar++;\n        if (c == '\\n') this.currentLine++;\n        return c;\n    }\n\n    // If the current character is [c], consumes it and returns `true`.\n    matchChar(c) {\n        if (this.peekChar() != c) return false;\n        this.nextChar();\n        return true;\n    }\n\n    // Sets the parser's current token to the given [type] and current character\n    // range.\n    makeToken(type) {\n        this.current.type = type;\n        this.current.start = this.tokenStart;\n        this.current.length = this.currentChar - this.tokenStart;\n        this.current.line = this.currentLine;\n\n        // Make line tokens appear on the line containing the \"\\n\".\n        if (type == 'TOKEN_LINE') this.current.line--;\n\n        this.tokens.push({\n            type: type,\n            value: this.source.substr(this.current.start, this.current.length),\n            line: this.current.line\n\n        });\n    }\n\n    // If the current character is [c], then consumes it and makes a token of type\n    // [two]. Otherwise makes a token of type [one].\n    twoCharToken(c, two, one) {\n        this.makeToken(this.matchChar(c) ? two : one);\n    }\n\n    // Skips the rest of the current line.\n    skipLineComment() {\n        while (this.peekChar() != '\\n' && this.peekChar() != '\\0') {\n            this.nextChar();\n        }\n    }\n\n    // Skips the rest of a block comment.\n    skipBlockComment() {\n        let nesting = 1;\n        while (nesting > 0) {\n            if (this.peekChar() == '\\0') {\n                this.lexError('Unterminated block comment.');\n                return;\n            }\n\n            if (this.peekChar() == '/' && this.peekNextChar() == '*') {\n                this.nextChar();\n                this.nextChar();\n                nesting++;\n                continue;\n            }\n\n            if (this.peekChar() == '*' && this.peekNextChar() == '/') {\n                this.nextChar();\n                this.nextChar();\n                nesting--;\n                continue;\n            }\n\n            // Regular comment character.\n            this.nextChar();\n        }\n    }\n\n    // Reads the next character, which should be a hex digit (0-9, a-f, or A-F) and\n    // returns its numeric value. If the character isn't a hex digit, returns -1.\n    readHexDigit() {\n        let c = this.nextChar();\n        if (c >= '0' && c <= '9') return c - '0';\n        if (c >= 'a' && c <= 'f') return c - 'a' + 10;\n        if (c >= 'A' && c <= 'F') return c - 'A' + 10;\n\n        // Don't consume it if it isn't expected. Keeps us from reading past the end\n        // of an unterminated string.\n        this.currentChar--;\n        return -1;\n    }\n\n    // Parses the numeric value of the current token.\n    makeNumber(isHex) {\n\n        if (isHex) {\n            this.current.value = parseInt(this.tokenStart, 16);\n        } else {\n            this.current.value = parseFloat(this.tokenStart);\n        }\n\n        this.makeToken('TOKEN_NUMBER');\n    }\n\n    // Finishes lexing a hexadecimal number literal.\n    readHexNumber() {\n        // Skip past the `x` used to denote a hexadecimal literal.\n        this.nextChar();\n\n        // Iterate over all the valid hexadecimal digits found.\n        while (this.readHexDigit() != -1) continue;\n\n        this.makeNumber(true);\n    }\n\n    // Finishes lexing a number literal.\n    readNumber() {\n        while (this.isDigit(this.peekChar())) this.nextChar();\n\n        // See if it has a floating point. Make sure there is a digit after the \".\"\n        // so we don't get confused by method calls on number literals.\n        if (this.peekChar() == '.' && this.isDigit(this.peekNextChar())) {\n            this.nextChar();\n            while (this.isDigit(this.peekChar())) this.nextChar();\n        }\n\n        // See if the number is in scientific notation.\n        if (this.matchChar('e') || this.matchChar('E')) {\n        // Allow a negative exponent.\n            this.matchChar('-');\n\n            if (!this.isDigit(this.peekChar())) {\n                this.lexError('Unterminated scientific notation.');\n            }\n\n            while (this.isDigit(this.peekChar())) this.nextChar();\n        }\n\n        this.makeNumber(false);\n    }\n\n    // Finishes lexing an identifier. Handles reserved words.\n    readName(type) {\n        while (this.isName(this.peekChar()) || this.isDigit(this.peekChar())) {\n            this.nextChar();\n        }\n\n        // Update the type if it's a keyword.\n        let length = this.currentChar - this.tokenStart;\n        for (let i = 0; i < keywords.length; i++) {\n            let name = this.source.substr(this.tokenStart, length);\n            if (name.length == keywords[i].length &&\n                name == keywords[i].identifier) {\n                type = keywords[i].tokenType;\n                break;\n            }\n        }\n\n        this.makeToken(type);\n    }\n\n    // Reads [digits] hex digits in a string literal and returns their number value.\n    readHexEscape(digits, description) {\n        let value = 0;\n        for (let i = 0; i < digits; i++) {\n            if (this.peekChar() == '\"' || this.peekChar() == '\\0') {\n                this.lexError('Incomplete ' + description + ' escape sequence.');\n\n                // Don't consume it if it isn't expected. Keeps us from reading past the\n                // end of an unterminated string.\n                this.currentChar--;\n                break;\n            }\n\n            let digit = this.readHexDigit();\n            if (digit == -1) {\n                this.lexError('Invalid ' + description + ' escape sequence.');\n                break;\n            }\n\n            value = (value * 16) | digit;\n        }\n\n        return value;\n    }\n\n    /* TODO\n    // Reads a hex digit Unicode escape sequence in a string literal.\n    readUnicodeEscape(string, length) {\n        let value = this.readHexEscape(length, 'Unicode');\n\n        // Grow the buffer enough for the encoded result.\n        let numBytes = wrenUtf8EncodeNumBytes(value);\n        if (numBytes != 0) {\n            wrenByteBufferFill(this.vm, string, 0, numBytes);\n            wrenUtf8Encode(value, string.data + string.count - numBytes);\n        }\n    }\n    */\n\n    // TODO\n    // Finishes lexing a string literal.\n    readString() {\n        //let string = '';\n        let type = 'TOKEN_STRING';\n\n        for (;;) {\n            let c = this.nextChar();\n            if (c == '\"') break;\n\n            if (c == '\\0') {\n                this.lexError('Unterminated string.');\n\n                // Don't consume it if it isn't expected. Keeps us from reading past the\n                // end of an unterminated string.\n                this.currentChar--;\n                break;\n            }\n\n            if (c == '%') {\n                if (this.numParens < MAX_INTERPOLATION_NESTING) {\n                    // TODO: Allow format string.\n                    if (this.nextChar() != '(') this.lexError('Expect \\'(\\' after \\'%%\\'.');\n\n                    this.parens[this.numParens++] = 1;\n                    type = 'TOKEN_INTERPOLATION';\n                    break;\n                }\n\n                this.lexError('Interpolation may only nest ' +\n            MAX_INTERPOLATION_NESTING + ' levels deep.');\n            }\n\n            if (c == '\\\\') {\n                console.log(123);\n                switch (this.nextChar()) {\n                //case '\"':  wrenByteBufferWrite(this.vm, string, '\"'); break;\n                //case '\\\\': wrenByteBufferWrite(this.vm, string, '\\\\'); break;\n                //case '%':  wrenByteBufferWrite(this.vm, string, '%'); break;\n                //case '0':  wrenByteBufferWrite(this.vm, string, '\\0'); break;\n                //case 'a':  wrenByteBufferWrite(this.vm, string, '\\a'); break;\n                //case 'b':  wrenByteBufferWrite(this.vm, string, '\\b'); break;\n                //case 'f':  wrenByteBufferWrite(this.vm, string, '\\f'); break;\n                //case 'n':  wrenByteBufferWrite(this.vm, string, '\\n'); break;\n                //case 'r':  wrenByteBufferWrite(this.vm, string, '\\r'); break;\n                case 't':  this.current.value =  '\\t'; break;\n                //case 'u':  this.readUnicodeEscape(string, 4); break;\n                //case 'U':  this.readUnicodeEscape(string, 8); break;\n                case 'v':  this.current.value = '\\v'; break;\n                case 'x':\n                    this.current.value = this.readHexEscape(2, 'byte');\n                    break;\n\n                default:\n                    this.lexError('Invalid escape character \\'' +\n                (this.currentChar - 1) + '\\'.');\n                    break;\n                }\n            }\n            //else\n            //{\n            //    string += c;\n            //}\n        }\n\n        this.makeToken(type);\n    }\n\n    // Lex the next token and store it in [parser.current].\n    nextToken() {\n        this.previous = this.current;\n\n        // If we are out of tokens, don't try to tokenize any more. We *do* still\n        // copy the TOKEN_EOF to previous so that code that expects it to be consumed\n        // will still work.\n        if (this.current.type == 'TOKEN_EOF') return;\n\n        while (this.peekChar() != '\\0')\n        {\n            this.tokenStart = this.currentChar;\n\n            let c = this.nextChar();\n            switch (c) {\n            case '(':\n                // If we are inside an interpolated expression, count the unmatched \"(\".\n                if (this.numParens > 0) this.parens[this.numParens - 1]++;\n                this.makeToken('TOKEN_LEFT_PAREN');\n                return;\n\n            case ')':\n            // If we are inside an interpolated expression, count the \")\".\n                if (this.numParens > 0 &&\n                --this.parens[this.numParens - 1] == 0)\n                {\n                    // This is the final \")\", so the interpolation expression has ended.\n                    // This \")\" now begins the next section of the template string.\n                    this.numParens--;\n                    this.readString();\n                    return;\n                }\n\n                this.makeToken('TOKEN_RIGHT_PAREN');\n                return;\n\n            case '[': this.makeToken('TOKEN_LEFT_BRACKET'); return;\n            case ']': this.makeToken('TOKEN_RIGHT_BRACKET'); return;\n            case '{': this.makeToken('TOKEN_LEFT_BRACE'); return;\n            case '}': this.makeToken('TOKEN_RIGHT_BRACE'); return;\n            case ':': this.makeToken('TOKEN_COLON'); return;\n            case ',': this.makeToken('TOKEN_COMMA'); return;\n            case '*': this.makeToken('TOKEN_STAR'); return;\n            case '%': this.makeToken('TOKEN_PERCENT'); return;\n            case '^': this.makeToken('TOKEN_CARET'); return;\n            case '+': this.makeToken('TOKEN_PLUS'); return;\n            case '-': this.makeToken('TOKEN_MINUS'); return;\n            case '~': this.makeToken('TOKEN_TILDE'); return;\n            case '?': this.makeToken('TOKEN_QUESTION'); return;\n\n            case '|': this.twoCharToken('|', 'TOKEN_PIPEPIPE', 'TOKEN_PIPE'); return;\n            case '&': this.twoCharToken('&', 'TOKEN_AMPAMP', 'TOKEN_AMP'); return;\n            case '=': this.twoCharToken('=', 'TOKEN_EQEQ', 'TOKEN_EQ'); return;\n            case '!': this.twoCharToken('=', 'TOKEN_BANGEQ', 'TOKEN_BANG'); return;\n\n            case '.':\n                if (this.matchChar('.'))\n                {\n                    this.twoCharToken('.', 'TOKEN_DOTDOTDOT', 'TOKEN_DOTDOT');\n                    return;\n                }\n\n                this.makeToken('TOKEN_DOT');\n                return;\n\n            case '/':\n                if (this.matchChar('/'))\n                {\n                    this.skipLineComment();\n                    break;\n                }\n\n                if (this.matchChar('*'))\n                {\n                    this.skipBlockComment();\n                    break;\n                }\n\n                this.makeToken('TOKEN_SLASH');\n                return;\n\n            case '<':\n                if (this.matchChar('<'))\n                {\n                    this.makeToken('TOKEN_LTLT');\n                }\n                else\n                {\n                    this.twoCharToken('=', 'TOKEN_LTEQ', 'TOKEN_LT');\n                }\n                return;\n\n            case '>':\n                if (this.matchChar('>'))\n                {\n                    this.makeToken('TOKEN_GTGT');\n                }\n                else\n                {\n                    this.twoCharToken('=', 'TOKEN_GTEQ', 'TOKEN_GT');\n                }\n                return;\n\n            case '\\n':\n                this.makeToken('TOKEN_LINE');\n                return;\n\n            case ' ':\n            case '\\r':\n            case '\\t':\n            // Skip forward until we run out of whitespace.\n                while (this.peekChar() == ' ' ||\n                   this.peekChar() == '\\r' ||\n                   this.peekChar() == '\\t')\n                {\n                    this.nextChar();\n                }\n                break;\n\n            case '\"': this.readString(); return;\n            case '_':\n                this.readName(\n                    this.peekChar() == '_' ? 'TOKEN_STATIC_FIELD' : 'TOKEN_FIELD');\n                return;\n\n            case '0':\n                if (this.peekChar() == 'x')\n                {\n                    this.readHexNumber();\n                    return;\n                }\n\n                this.readNumber();\n                return;\n\n            default:\n                if (this.currentLine == 1 && c == '#' && this.peekChar() == '!')\n                {\n                    // Ignore shebang on the first line.\n                    this.skipLineComment();\n                    break;\n                }\n                if (this.isName(c))\n                {\n                    this.readName('TOKEN_NAME');\n                }\n                else if (this.isDigit(c))\n                {\n                    this.readNumber();\n                }\n                else\n                {\n                    if (c >= 32 && c <= 126)\n                    {\n                        this.lexError('Invalid character \\'' + c + '\\'.');\n                    }\n                    else\n                    {\n                        // Don't show non-ASCII values since we didn't UTF-8 decode the\n                        // bytes. Since there are no non-ASCII byte values that are\n                        // meaningful code units in Wren, the lexer works on raw bytes,\n                        // even though the source code and console output are UTF-8.\n                        this.lexError('Invalid byte 0x' + c + '.');\n                    }\n                    this.current.type = 'TOKEN_ERROR';\n                    this.current.length = 0;\n                }\n                return;\n            }\n        }\n\n        // If we get here, we're out of source, so just make EOF tokens.\n        this.tokenStart = this.currentChar;\n        this.makeToken('TOKEN_EOF');\n    }\n\n\n    // Outputs a lexical error.\n    lexError(format) {\n        console.warn([this.currentLine, 'Error', format]);\n    }\n\n}\n\n\n//# sourceURL=webpack://Wrent/./src/main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__("./src/main.js");
/******/ })()
;